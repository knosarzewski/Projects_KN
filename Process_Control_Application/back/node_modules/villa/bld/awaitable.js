"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { EventEmitter: EventEmitterConstructor } = safeRequire('events');
const { ChildProcess: ChildProcessConstructor } = safeRequire('child_process');
const { Readable: ReadableConstructor, Writable: WritableConstructor } = safeRequire('stream');
let awaitableCreators = [];
function getEventEmitterAwaitableOptions(emitter) {
    if (ChildProcessConstructor && emitter instanceof ChildProcessConstructor) {
        return {
            types: ['exit'],
            assertion(code) {
                if (code !== 0) {
                    throw new Error(`Invalid exit code ${code}`);
                }
            }
        };
    }
    else if (ReadableConstructor && emitter instanceof ReadableConstructor ||
        WritableConstructor && emitter instanceof WritableConstructor) {
        return {
            types: ['close']
        };
    }
    else {
        throw new Error('Missing event types');
    }
}
function eventEmitterAwaitableCreator(emitter, types, assertion = [], errorEmitters) {
    if (!(emitter instanceof EventEmitterConstructor)) {
        return undefined;
    }
    if (typeof types === 'string' || isStringArray(types)) {
        if (typeof types === 'string') {
            types = [types];
        }
        if (Array.isArray(assertion)) {
            errorEmitters = assertion;
            // TODO: possibly a bug of TypeScript 2.2, adding ! temporarily.
            assertion = undefined;
        }
    }
    else {
        errorEmitters = types;
        let options = getEventEmitterAwaitableOptions(emitter);
        types = options.types;
        // TODO: possibly a bug of TypeScript 2.2, adding ! temporarily.
        assertion = options.assertion;
    }
    if (!errorEmitters) {
        errorEmitters = [];
    }
    errorEmitters.unshift(emitter);
    let promise = new Promise((resolve, reject) => {
        for (let type of types) {
            emitter.on(type, onsuccess);
        }
        for (let emitter of errorEmitters) {
            emitter.on('error', onerror);
        }
        function removeListeners() {
            for (let type of types) {
                emitter.removeListener(type, onsuccess);
            }
            for (let emitter of errorEmitters) {
                emitter.removeListener('error', onerror);
            }
        }
        function onsuccess(value) {
            removeListeners();
            resolve(value);
        }
        function onerror(error) {
            setImmediate(removeListeners);
            reject(error);
        }
    });
    if (assertion) {
        promise = promise.then(assertion);
    }
    return promise;
}
/* istanbul ignore else */
if (EventEmitterConstructor) {
    awaitableCreators.push(eventEmitterAwaitableCreator);
}
/**
 * Create a promise for an event emitter.
 * @param emitter The emitter to listen on 'error' event for rejection, and
 *     given event types for fulfillment.
 * @param type A string or an array of string of event types for fulfillment.
 * @param errorEmitters Other emitters to listen on 'error' event for
 *     rejection.
 */
function awaitable(target, ...args) {
    for (let creator of awaitableCreators) {
        let promise = creator(target, ...args);
        if (promise) {
            return promise;
        }
    }
    throw new TypeError('Cannot create awaitable from the target object with given arguments');
}
exports.awaitable = awaitable;
function safeRequire(id) {
    try {
        return require(id);
    }
    catch (error) {
        /* istanbul ignore next */
        return {};
    }
}
function isStringArray(object) {
    return Array.isArray(object) && typeof object[0] === 'string';
}
//# sourceMappingURL=awaitable.js.map