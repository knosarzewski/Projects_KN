import { Resolvable, EachHandler, EveryHandler, FilterHandler, FindHandler, MapTransformer, ParallelHandler, RaceTransformer, ReduceTransformer, SomeHandler } from './';
export declare class Chainable<T> extends Promise<T[]> {
    each(handler: EachHandler<T>): Promise<boolean>;
    every(handler: EveryHandler<T>): Promise<boolean>;
    filter(handler: FilterHandler<T>): Chainable<T>;
    find(handler: FindHandler<T>): Promise<T | undefined>;
    findIndex(handler: FindHandler<T>): Promise<number>;
    map<TResult>(transformer: MapTransformer<T, TResult>, concurrency?: number): Chainable<TResult>;
    parallel(handler: ParallelHandler<T>, concurrency?: number): Promise<void>;
    race<TResult>(transformer: RaceTransformer<T, TResult>): Promise<TResult>;
    reduce<TResult>(transformer: ReduceTransformer<T, TResult[]>, initial: TResult[]): Chainable<TResult>;
    reduce<TResult>(transformer: ReduceTransformer<T, TResult>, initial: TResult): Promise<TResult>;
    reduce(transformer: ReduceTransformer<T, T>): Promise<T>;
    reduceRight<TResult>(transformer: ReduceTransformer<T, TResult[]>, initial: TResult[]): Chainable<TResult>;
    reduceRight<TResult>(transformer: ReduceTransformer<T, TResult>, initial: TResult): Promise<TResult>;
    reduceRight(transformer: ReduceTransformer<T, T>): Promise<T>;
    some(handler: SomeHandler<T>): Promise<boolean>;
    static resolve(): Promise<any>;
    static resolve<T>(resolvable: Resolvable<T[]>): Chainable<T>;
}
/**
 * Wrap given resolvable with a chainable derived of built-in promise.
 */
export declare function chainable<T>(resolvable: Resolvable<T[]>): Chainable<T>;
